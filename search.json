[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Blog",
    "section": "",
    "text": "data.frame vs tibble\n\n\n\nR\n\nbase::data.frame\n\ntibble::tibble\n\ntibble::tribble\n\n\n\nComparing data.frame and tibble behavior in R: creation, subsetting, printing, and more.\n\n\n\n\n\nJul 23, 2025\n\n\nfilebb\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nApr 11, 2025\n\n\nTristan O’Malley\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html",
    "href": "posts/data-frame-vs-tibble/index.html",
    "title": "\ndata.frame vs tibble\n",
    "section": "",
    "text": "In R, tabular data is typically stored using either a data.frame or a tibble.\nWhile they serve similar purposes, their behavior diverges in ways that affect printing, subsetting, and workflow safety.\nThis post compares their creation and structure, highlights key differences, and explains why tibbles are often the preferred choice in modern tidyverse workflows."
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html#list-name-extractor",
    "href": "posts/data-frame-vs-tibble/index.html#list-name-extractor",
    "title": "\ndata.frame vs tibble\n",
    "section": "List Name Extractor $\n",
    "text": "List Name Extractor $\n\nIn R, the $operator, formally known as the list name extractor, is used to access elements by name from objects that behave like lists, such as data.frames and tibbles.\n\ndf$values\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\ntbl$values\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\nIn both structures, $ returns the column as a vector. But if the column name doesn’t exist:\n\ndf$missing_column   # Returns NULL silently\n## NULL\n\ntbl$missing_column  # Warning: unknown column, returns NULL\n## Warning: Unknown or uninitialised column: `missing_column`.\n## NULL\n\nTibbles are stricter—they issue a warning when a column is missing. This makes them safer for debugging and helps catch typos or mismatched names early in the workflow.\nNote that the common $ syntax is a syntactic sugar:\n\nidentical(base::`$`(df, \"values\"), df$values)\n## [1] TRUE\n\nidentical(base::`$`(tbl, \"values\"), tbl$values)\n## [1] TRUE"
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html#partial-matching",
    "href": "posts/data-frame-vs-tibble/index.html#partial-matching",
    "title": "\ndata.frame vs tibble\n",
    "section": "Partial Matching",
    "text": "Partial Matching\nUnlike tibbles, base R data.frames allow partial matching when accessing column names:\n\ndf$val # Matches 'values'\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\ntbl$val # Warning: no such column, returns NULL\n## Warning: Unknown or uninitialised column: `val`.\n## NULL\n\nBase R’s partial matching stems from legacy flexibility, allowing quick exploratory coding. But in production workflows, this flexibility can introduce silent errors. Tibbles’ stricter behavior is generally safer. Consider the following example:\n\ndf$let # Ambiguous: matches multiple columns, returns NULL silently\n## NULL\n\ntbl$let # Warning: requires exact match, returns NULL\n## Warning: Unknown or uninitialised column: `let`.\n## NULL\n\nIn data.frame, $let silently returns NULL, since multiple columns begin with 'let'. No warning is issued, making it easy to miss, especially inside larger pipelines or wrapped functions.\nTibbles, by contrast, enforce exact matching. They generate a warning when the column name isn’t found, helping you catch typos and ambiguous references early. This constraint reduces hidden bugs and promotes safer, more reliable code through clear intent."
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html#bracket-subsetting-with-colname",
    "href": "posts/data-frame-vs-tibble/index.html#bracket-subsetting-with-colname",
    "title": "\ndata.frame vs tibble\n",
    "section": "Bracket Subsetting with [\"colname\"]\n",
    "text": "Bracket Subsetting with [\"colname\"]\n\nWhen selecting one column with subset operator [, both structures preserve column names and types, but the returned object matches the source:\n\ndf[\"values\"] # Returns a one-column data.frame\n##    values\n## 1     1.1\n## 2     1.2\n## 3     1.3\n## 4     1.4\n## 5     1.5\n## 6     1.6\n## 7     1.7\n## 8     1.8\n## 9     1.9\n## 10    2.0\n## 11    2.1\n## 12    2.2\n## 13    2.3\n## 14    2.4\n## 15    2.5\n## 16    2.6\n## 17    2.7\n## 18    2.8\n## 19    2.9\n## 20    3.0\n## 21    3.1\n## 22    3.2\n## 23    3.3\n## 24    3.4\n## 25    3.5\n## 26    3.6\n\nclass(df) == class(df[\"values\"])\n## [1] TRUE\n\ntbl[\"values\"] # Returns a one-column tibble\n## # A tibble: 26 × 1\n##    values\n##     &lt;dbl&gt;\n##  1    1.1\n##  2    1.2\n##  3    1.3\n##  4    1.4\n##  5    1.5\n##  6    1.6\n##  7    1.7\n##  8    1.8\n##  9    1.9\n## 10    2  \n## # ℹ 16 more rows\n\nclass(tbl) == class(tbl[\"values\"])\n## [1] TRUE TRUE TRUE\n\nThis consistency helps maintain predictable behavior in pipelines and avoids surprises when chaining operations.\nNote that the common [ syntax is a syntactic sugar:\n\nidentical(base::`[`(df, \"values\"), df[\"values\"])\n## [1] TRUE\n\nidentical(base::`[`(tbl, \"values\"), tbl[\"values\"])\n## [1] TRUE\n\nSubset operator can be used to select more columns:\n\ndf[c(\"numbers\", \"letters_upper\")]\n##    numbers letters_upper\n## 1        1             A\n## 2        2             B\n## 3        3             C\n## 4        4             D\n## 5        5             E\n## 6        6             F\n## 7        7             G\n## 8        8             H\n## 9        9             I\n## 10      10             J\n## 11      11             K\n## 12      12             L\n## 13      13             M\n## 14      14             N\n## 15      15             O\n## 16      16             P\n## 17      17             Q\n## 18      18             R\n## 19      19             S\n## 20      20             T\n## 21      21             U\n## 22      22             V\n## 23      23             W\n## 24      24             X\n## 25      25             Y\n## 26      26             Z\n\ntbl[c(\"numbers\", \"letters_upper\")]\n## # A tibble: 26 × 2\n##    numbers letters_upper\n##      &lt;int&gt; &lt;chr&gt;        \n##  1       1 A            \n##  2       2 B            \n##  3       3 C            \n##  4       4 D            \n##  5       5 E            \n##  6       6 F            \n##  7       7 G            \n##  8       8 H            \n##  9       9 I            \n## 10      10 J            \n## # ℹ 16 more rows\n\nA numerical vector with columns position can also be provided:\n\nidentical(df[\"values\"], df[3])\n## [1] TRUE\n\nidentical(tbl[\"values\"], tbl[3])\n## [1] TRUE\n\nidentical(df[c(\"numbers\", \"letters_upper\")], df[c(2, 5)])\n## [1] TRUE\n\nidentical(tbl[c(\"numbers\", \"letters_upper\")], tbl[c(2, 5)])\n## [1] TRUE"
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html#bracket-subsetting-with-colname-1",
    "href": "posts/data-frame-vs-tibble/index.html#bracket-subsetting-with-colname-1",
    "title": "\ndata.frame vs tibble\n",
    "section": "Bracket Subsetting with [ , \"colname\"]\n",
    "text": "Bracket Subsetting with [ , \"colname\"]\n\nWhen subsetting with two indices, i.e. df[, \"values\"] we’re instructing R to return all rows and a named column by character reference. While this syntax appears identical across data.frame and tibble, the behavior differs in a meaningful way:\n\ndf[, \"values\"] # Returns a vector (column extracted)\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\nbase::is.data.frame(df[, \"values\"])\n## [1] FALSE\n\nbase::class(df[, \"values\"])\n## [1] \"numeric\"\n\nutils::str(df[, \"values\"])\n##  num [1:26] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 ...\n\ntbl[, \"values\"] # Returns a tibble (preserves tbl_df structure)\n## # A tibble: 26 × 1\n##    values\n##     &lt;dbl&gt;\n##  1    1.1\n##  2    1.2\n##  3    1.3\n##  4    1.4\n##  5    1.5\n##  6    1.6\n##  7    1.7\n##  8    1.8\n##  9    1.9\n## 10    2  \n## # ℹ 16 more rows\n\ntibble::is_tibble(tbl[, \"values\"])\n## [1] TRUE\n\nbase::class(tbl[, \"values\"])\n## [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\nutils::str(tbl[, \"values\"])\n## tibble [26 × 1] (S3: tbl_df/tbl/data.frame)\n##  $ values: num [1:26] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2 ...\n\nThis behavior reflects tibble’s design philosophy: predictable and structure-preserving results, especially useful in tidyverse pipelines."
  },
  {
    "objectID": "posts/data-frame-vs-tibble/index.html#extracting-columns-with-colname-or-position",
    "href": "posts/data-frame-vs-tibble/index.html#extracting-columns-with-colname-or-position",
    "title": "\ndata.frame vs tibble\n",
    "section": "Extracting Columns with [[ \"colname\" ]] or [[ position ]]\n",
    "text": "Extracting Columns with [[ \"colname\" ]] or [[ position ]]\n\nThe double-bracket operator [[ is used to extract elements by name or position with exact intent. Unlike [, which returns a one-column data.frame or tibble, [[ returns the column as a vector.\n\ndf[[\"values\"]] # Returns a vector\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\ntbl[[\"values\"]] # Returns a vector\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\n[[ supports also numeric indexing:\n\nall(df[[\"values\"]]== df[[3]])\n## [1] TRUE\n\nall(df[[\"values\"]] == tbl[[3]])\n## [1] TRUE\n\nContrary to [, [[ only allows extraction of a single element, not multiple columns:\n\ndf[[c(1,3)]]  # FALSE\n## [1] FALSE\n\ntbl[[c(1,3)]]  # Error: only one element (column) can be extracted\n## Error:\n## ! The `j` argument of `[[.tbl_df()` can't be a vector of length 2 as of\n##   tibble 3.0.0.\n## ℹ Recursive subsetting is deprecated for tibbles.\n\nWhat happens in the data.frame case is that when you pass c(1, 3) to df[[ ]], R doesn’t extract multiple columns. Instead, it interprets the whole vector as a compound index, which is valid but not intuitive. In pratice df[[c(1, 3)]] is equivalent to df[[1]][3]:\n\nidentical(df[[c(1, 3)]], df[[1]][3])\n## [1] TRUE\n\nIn tidyverse workflows, dplyr::pull is a friendly wrapper around [[, with added clarity:\n\ndf |&gt; dplyr::pull(\"values\")\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\ntbl |&gt; dplyr::pull(\"values\")\n##  [1] 1.1 1.2 1.3 1.4 1.5 1.6 1.7 1.8 1.9 2.0 2.1 2.2 2.3 2.4 2.5 2.6 2.7 2.8 2.9\n## [20] 3.0 3.1 3.2 3.3 3.4 3.5 3.6\n\nNote: pull works seamlessly with both data.frame and tibble.\nAs with $ and [ ], the [[ ]] operator is syntactic sugar:\n\nall(base::`[[`(df, \"values\") == df[[\"values\"]])\n## [1] TRUE\n\nall(base::`[[`(tbl, \"values\") == tbl[[\"values\"]])\n## [1] TRUE"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  }
]