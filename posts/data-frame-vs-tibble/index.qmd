---
title: "`data.frame` vs `tibble`"
date: "2025-07-23"
categories: [R, base::data.frame, tibble::tibble, tibble::tribble]
editor_options: 
  chunk_output_type: console
---

# Introduction

When working with tabular data in R, you’ll often choose between two structures:
`data.frame` and `tibble`.
This post breaks down how to create them, explores their behavior, and explains
why tibbles are often preferred in modern workflows.

# Create

Base R provides a data structure, called `data.frame`, to store and manipulate
tabular data.

A `data.frame` is an R `list` of equal-length vectors.

Here’s how to create a simple two-column `data.frame` using base R:

```{r}
df <-
  base::data.frame(
    is_vowel      = c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE,
                      TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,
                      FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE,
                      FALSE, FALSE),
    numbers       = 1:26,
    values        = seq(1.1, by = 0.1, length.out = 26),
    letters_lower = letters, # Built-in vector: "a" to "z"
    letters_upper = LETTERS  # Built-in vector: "A" to "Z"
  )
```

The tidyverse alternative is a `tibble`, a modern version of `data.frame`
designed to simplify data handling and prevent common pitfalls, like automatic
conversion of strings to factors or row name behavior.
Tibbles eliminate many of the quirks of base R `data.frame`, making them safer
and more predictable in data workflows.

And here's the `tibble` equivalent using tidyverse syntax:

```{r}
tbl <-
  tibble::tibble(
    is_vowel      = c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE,
                      TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE, FALSE,
                      FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE,
                      FALSE, FALSE),
    numbers       = 1:26,
    values        = seq(1.1, by = 0.1, length.out = 26),
    letters_lower = letters,
    letters_upper = LETTERS
  )
```

While both structures store the same data, their behavior diverges in subtle but
important ways. Let's look at how they differ when printed, subsetted, or used
in a pipeline.

# Class

Although `df` and `tbl` store the same data, they belong to different object
classes:

```{r}
base::class(df)

base::class(tbl)
```

Tibbles extend base data-frames by layering two additional classes: `tbl` and
`tbl_df`.
This hierarchy enables customized printing, stricter subsetting, and
compatibility with tidyverse functions, while maintaining full interoperability
with functions expecting a `data.frame`.

For a more targeted class check, use `base::inherits`:

```{r}
base::inherits(df, "data.frame")

base::inherits(tbl, "data.frame")

base::inherits(df, "tbl")

base::inherits(tbl, "tbl")
```

# Structure Comparison

Both `df` and `tbl` are technically `list`s under the hood, but `tibble`s carry
extra metadata for printing and structure.
Let’s inspect them:

```{r}
base::typeof(df)

base::typeof(tbl)
```

Using `typeof()` they appear identical.
But `str()` reveals more subtle differences:

```{r}
utils::str(df)

utils::str(tbl)
```

This reinforces the idea that tibbles are still lists with class `data.frame`,
but their extra class layers change how they behave and display.

# Print

The first thing you’ll notice is how differently `data.frame` and `tibble`
print.
Tibbles have a print method that shows only the first 10 rows, and all the
columns that fit on screen.
This makes working with large datasets much easier.
Each column in a tibble includes a compact type annotation, such as:

- `<lgl>` — logical
- `<int>` — integer
- `<dbl>` — double
- `<chr>` — character

Let’s print both and compare their outputs.

```{r}
df

tbl
```

# Subset

Both `data.frame`s and `tibble`s support subsetting with `$`, `[`,
and `[[`, but they behave differently in edge cases. Tibbles tend to be
stricter and more predictable, helping catch subtle bugs early.

## List Name Extractor `$`

In R, the `$ `operator, formally known as the **list name extractor**, is used
to access elements by name from objects that behave like `list`s, such as
`data.frame`s and `tibble`s.

```{r}
df$values

tbl$values
```

In both structures, `$` returns the column as a vector. But if the column name
doesn’t exist:

```{r}
df$missing_column   # Returns NULL silently

tbl$missing_column  # Warning: unknown column, returns NULL
```

Tibbles are stricter—they issue a warning when a column is missing. This makes
them safer for debugging and helps catch typos or mismatched names early in the
workflow.

Note that the common `$` syntax is a syntactic sugar:

```{r}
all(base::`$`(df, "values") == df$values)

all(base::`$`(tbl, "values") == tbl$values)
```

## Partial Matching

Unlike `tibble`s, base R `data.frame`s allow partial matching when accessing
column names:

```{r}
df$val # Matches 'values'

tbl$val # Warning: no such column, returns NULL
```

Base R’s partial matching stems from legacy flexibility, allowing quick
exploratory coding.
But in production workflows, this flexibility can introduce silent errors.
Tibbles' stricter behavior is generally safer.
Consider the following example:

```{r}
df$let # Ambiguous: matches multiple columns, returns NULL silently

tbl$let # Warning: requires exact match, returns NULL
```

In `data.frame`, `$let` silently returns `NULL`, since multiple columns begin
with `'let'`.
No warning is issued, making it easy to miss, especially inside larger pipelines
or wrapped functions.

Tibbles, by contrast, enforce exact matching.
They generate a warning when the column name isn’t found, helping you catch
typos and ambiguous references early.
This constraint reduces hidden bugs and promotes safer, more reliable code
through clear intent.

## Bracket Subsetting: One-Dimensional

When selecting one column with subset operator `[`, both structures preserve
column names and types, but the returned object matches the source:

```{r}
df["values"] # Returns a one-column data.frame

class(df) == class(df["values"])

tbl["values"] # Returns a one-column tibble

class(tbl) == class(tbl["values"])
```

This consistency helps maintain predictable behavior in pipelines and avoids
surprises when chaining operations.

Note that the common `[` syntax is a syntactic sugar:

```{r}
all(base::`[`(df, "values") == df["values"])

all(base::`[`(tbl, "values") == tbl["values"])
```

Subset operator can be used to select more columns:

```{r}
df[c("numbers", "letters_upper")]

tbl[c("numbers", "letters_upper")]
```

A numerical vector with columns position can also be provided:

```{r}
all(df["values"] == df[3])

all(tbl["values"] == tbl[3])

all(df[c("numbers", "letters_upper")] == df[c(2, 5)])

all(tbl[c("numbers", "letters_upper")] == tbl[c(2, 5)])
```

## Bracket Subsetting with `[ , "colname"]`

When subsetting with two indices, i.e. `df[, "values"]` we’re instructing R to
return all rows and a named column by character reference. While this syntax
appears identical across `data.frame` and `tibble`, the behavior differs in a
meaningful way:

```{r}
df[, "values"] # Returns a vector (column extracted)

base::is.data.frame(df[, "values"])

base::class(df[, "values"])

utils::str(df[, "values"])

tbl[, "values"] # Returns a tibble (preserves tbl_df structure)

tibble::is_tibble(tbl[, "values"])

base::class(tbl[, "values"])

utils::str(tbl[, "values"])
```

This behavior reflects tibble’s design philosophy: predictable and
structure-preserving results, especially useful in tidyverse pipelines.

# Add a New Column Using `$`

Adding a new column to a `data.frame` using `$` will recycle the vector used if
its length is less than the number of rows of the `data.frame` (but assuming
that the number of elemnts of the vector is a submultiple of the number of rows
of the `data.frame`).

```{r}
# df$other_numbers <- 27:28
# 
# df$other_numbers
# 
# df
```

In general, a `tibble` does not allow it

```{r}
#| error: true

# tbl$other_numbers <- 27:28
```

Unless we want to add a constant column

```{r}
# tbl$constant_column <- 7
# 
# tbl$constant_column
# 
# tbl
```

Note that if the length of the vector used to define a new column is equal to
the number of rows of the tibble, then everything will run smoothly.

```{r}
#| echo: false
tbl <-
  tibble::tibble(
    letters = letters,
    numbers = 1:26
  )
```

```{r}
tbl$other_numbers <- 27:52

tbl$other_numbers

tbl
```

# Summary of Differences

| Feature          | `data.frame`            | `tibble`                         |
|:-----------------|:------------------------|:---------------------------------|
| Class            | `data.frame`            | `tbl_df`, `tbl`, `data.frame`    |
| Printing         | Entire object           | First 10 rows + compact metadata |
| `$` with typo    | Returns `NULL` silently | Returns `NULL` with warning      |
| Partial Matching | Allowed                 | Disallowed                       |
| Subset `[`       | Returns `data.frame`    | Returns `tibble`                 |

# Create by Row: tribble()

The `tibble::tribble()` function ("transposed tibble") offers a readable,
row-wise syntax that makes small tables clearer, especially in documentation,
examples, and teaching material.

```{r}
tibble::tribble(
  ~letters, ~numbers,
  "a",      1,
  "b",      2,
  "c",      3
)
```

Advantages:

- Column headers preceded by `~`: Visually distinguishes variables.

- Row-wise entry: Mirrors how we often conceptualize tables.

- Safe type inference: Similar to `tibble()`, avoids surprises.

Base R doesn't offer a native row-wise constructor for `data.frame`, and there
are not simple workarounds (as far as I know!). Base R can construct row-wise
structures using `rbind`, but these have major limitations:

```{r}
base::rbind(
  c("a", 1),
  c("b", 2),
  c("c", 3)
)
```

This returns a character `matrix` not a `data.frame`. Type information is lost
due to coercion:

```{r}
base::rbind(
  c("a", 1),
  c("b", 2),
  c("c", 3)
) |>
  typeof()
```

# References

- [Tibble](https://tibble.tidyverse.org/index.html) package documentation

- [Tibble](https://posit.co/blog/tibble-1-0-0/) from Posit blog
